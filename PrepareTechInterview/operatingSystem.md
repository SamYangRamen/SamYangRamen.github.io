# 운영체제

컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고, 효과적으로 사용할 수 있도록 환경을 제공하는 **여러 프로그램의 모임**.

운영체제는 소프트웨어로서 전원이 켜짐과 동시에 메모리에 올라가야 한다. 하지만, 운영체제처럼 규모가 큰 프로그램이 모두 메모리에 올라간다면 한정된 메모리 공간의 낭비가 심할것이다. 따라서 운영체제 중 **항상 필요한 부분**만을 전원이 켜짐과 동시에 메모리에 올려놓고 그렇지 않은 부분은 필요할 때 메모리에 올려서 사용하게 된다. 이 때 **메모리에 상주하는 운영체제의 부분을 커널**이라 한다.

## Process & Thread

### Process

- 실행 중인 프로그램의 인스턴스

- 운영체제로부터 자신만의 독립된 메모리 영역을 할당받는다.

  - Code : 프로그램 소스코드 자체
  - Data : 전역변수, Static 변수, 배열, 구조체 등
  - Heap : 동적 할당
  - Stack : 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)

- 프로세스들은 독립적인 것이기 때문에, 한 프로세스가 다른 프로세스의 자원에 접근하려면 IPC(Inter Process Communication)를 사용해야 한다.

  - IPC : 파이프, 메시지 큐, 소켓 등을 이용한 통신

- 프로세스는 최소 1개의 쓰레드(메인 쓰레드)를 가지고 있다.

### Thread

- 프로세스 내의 실행 단위
- 프로세스의 자원을 쓰레드끼리 공유하기 때문에, 다른 쓰레드에 의한 결과를 즉시 확인할 수 있다.
- 단, 프로세스 내에서 Stack만 따로 할당받고, Code, Data, Heap 영역은 공유한다.
  - Stack을 독립적으로 할당하는 이유는, 쓰레드의 추가, 즉 독립적인 실행 흐름을 추가하기 위한 최소 조건이기 때문

### Multi-Processing

- 하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 1개의 작업을 처리하도록 하는 것

- 장점 : 안전성. 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다.
- 단점 : 비효율성. 프로세스들이 각각 독립된 메모리 영역을 갖기 때문에 Multi-Threading보다 많은 메모리 공간과 CPU 시간을 차지한다.

### Multi-Threading

- 하나의 프로그램을 여러 개의 쓰레드로 구성하여 각 쓰레드가 1개의 작업을 처리하도록 하는 것

- 장점 : 효율성. 쓰레드들이 같은 메모리 영역을 공유하기 때문에 Multi-Processing보다 적은 메모리 공간을 차지하고 Context Switching이 빠르다.
- 단점 : 위험성. 오류로 인해 하나의 쓰레드가 종료되면 전체 쓰레드가 종료될 위험이 있다.

### Context Switching

- 인터럽트를 발생시켜 CPU에서 현재 실행 중인 프로세스를 중단하고, 처리하고자 하는 다른 프로세스의 상태 정보를 CPU에 불러오는 과정
  - 인터럽트(Interrupt) : 예외 상황의 처리가 필요함을 CPU에게 알리는 것
- 현재 실행 중인 프로세스의 상태를 PCB에 저장하고, 다음 프로세스의 PCB 정보를 바탕으로 다음 프로세스를 동작시켜 작업을 처리한 후에, 이전에 저장되었던 프로세스의 상태를 해당 PCB로부터 다시 복구한다.
  - PCB(Process Control Block)
    - 각 프로세스에 대한 중요한 정보를 저장하는 자료구조
    - 프로세스가 생성/완료되면 해당 PCB가 생성/제거된다.

---

## 프로세스 관리

### 프로세스 상태 전이도

![image](https://user-images.githubusercontent.com/53200166/157440132-0b4292d2-ed4c-4593-93b0-d4d0fc2a6b47.png)

- 프로세스 상태
  - job : 실행 가능한 파일
  - created : job으로부터 프로세스가 생성된 상태
  - ready : 프로세스가 필요한 메모리 자원을 할당받고 CPU에 적재되기 위해 기다리는 상태
  - running : 프로세스가 CPU에 적재되어 실행 중인 상태
  - terminated : 프로세스가 종료되는 상태
  - asleep : I/O 요청 및 서비스가 끝날 때까지 기다리는 상태
  - suspended ready : 프로세스에 자원 할당이 불가능한 상태
  - suspended blocked : I/O 서비스 중 자원을 빼앗긴 상태
- 프로세스 상태 전이
  - dispatch : 프로세스 스케줄러에 의해 결정된 우선순위에 따라 프로세스가 CPU에 적재되는 것
  - time out : 실행 중이던 프로세스가 제한된 시간을 다 소비하여 CPU 점유를 빼앗기는 것
  - block : 실행 중이던 프로세스가 I/O 등 외부 요인에 의해 자원을 빼앗기는 것
  - wake up : I/O가 끝나는 것
  - swap-in : 프로세스가 필요한 자원을 할당받는 것
  - swap-out : 프로세스가 필요한 자원을 빼앗기는 것

### 스케줄링의 종류

- 장기 스케줄링(Long-term scheduling) : 프로세스의 실행 자격 여부 결정 작업 및 프로세스 개수 조절 작업
- 중기 스케줄링(Middle-term scheduling) : suspended 상태의 프로세스들 중 누구에게 먼저 메모리 자원을 할당할지 결정하는 작업
- 단기 스케줄링(Short-term scheduling) : ready queue에 있는 프로세스들의 CPU 할당 순서를 결정하는 작업
  - 프로세스 스케줄링, CPU 스케줄링이라고도 한다.

### CPU 스케줄링 알고리즘

- 비선점 스케줄링 : 한 번 CPU에 할당되면 끝까지 실행되는 것을 보장

  - FCFS(First Come First Served) : 먼저 온 순서대로 할당
  - SJF(Shortest Job First) : CPU time이 짧은 순서대로 할당

- 선점 스케줄링 : 현재 실행중인 프로세스에게서 CPU를 강제로 회수할 수 있음

  - RR(Round Robin) : 먼저 온 순서대로 할당하되, 모두 같은 크기의 CPU time을 가짐

  - SRTF(Shortest Remaning Time First) : 남은 CPU time이 짧은 순서대로 할당

  - 다단계 큐(Multi-Level Queue) : 우선순위가 서로 다른 Ready queue가 여러 개이며, 각 queue는 독자적으로 스케줄링 알고리즘을 수행함. queue들 간의 프로세스 이동이 불가능함
  - 다단계 피드백 큐(Multi-Level Feedback Queue) : 다단계 큐 + 큐들 간의 프로세스 이동이 가능함

---

## 프로세스 동기화 (Process Synchronization)

### 경쟁 상태(Race Condition)

- 여러 프로세스가 공유 자원에 동시에 접근하여 결과값에 영향을 줄 수 있는 상태. 즉, 어떤 자원을 두고 여러 프로세스들이 경쟁하는 상태

- 예시 : 한 은행 계좌에 두 명이 동시에 입금/인출할 때

  ```java
  void deposit(int amount) {
    balance = balance + amount;
  }
  void withdraw(int amount) {
    balance = balance - amount;
  }
  ```

### 임계 구역(Critical Section)

- Multi-Process 환경에서 둘 이상의 프로세스가 동시에 접근할 수 있는 코드 영역
- 여러 프로세스가 동시에 Critical Section에 접근을 한다면 **Race Condition** 문제가 발생할 수 있다. 즉, 데이터의 일관성이 파괴된다.

### 프로세스 동기화

- 공유 데이터에 두 개 이상의 프로세스가 동시에 접근하는 것을 막는 것, 그럼으로써 데이터의 일관성을 유지하는 것

### 프로세스 동기화의 조건

※ 사람들은 'Critical Section 문제를 해결하기 위한 조건'이라고 더 많이 일컫는다.

- 상호 배제(**Mut**ual **Ex**clusion, Mutex) : 하나의 프로세스가 Critical Section에 들어가 있으면 다른 프로세스는 들어갈 수 없다.
- 진행(Progress) : Critical Section에 들어간 프로세스가 없다면, 어느 프로세스가 들어갈 것인지 적절히 선택해줘야 한다.
- 한정 대기(Bounded Waiting) : 어떤 프로세스가 영원히 공유 자원에 접근하지 못하는 상황이 발생하는 것을 막기 위해, 이미 Critical Section에 들어갔던 프로세스는 다음 번 접근에 제한을 두어야 한다.

### 프로세스 동기화의 방법 : Mutex vs Semaphore

| Mutex                                                                                                                   | Semaphore                                                                                |
| ----------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| 오직 하나의 쓰레드만이 Lock/Unlock을 수행한 뒤 Critical Section을 진입/탈출할 수 있다. 즉, 동기화 대상이 오직 하나이다. | 여러 쓰레드가 Critical Section에 동시에 진입할 수 있다. 즉, 동기화 대상이 하나 이상이다. |
| Lock/Unlock 동작을 통해 다른 스레드의 접근을 막는다.                                                                    | 접근 가능한 스레드의 수를 제한하는 변수이다.                                             |
| Mutex는 semaphore가 될 수 없다.                                                                                         | 이진 변수일 때, Mutex와 같다.                                                            |

---

## 교착 상태 (DeadLock)

둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 상황

### DeadLock의 4가지 조건

- 상호 배제(Mutual Exclusion) : 한번에 한 프로세스만 공유 자원에 접근할 수 있다.
- 점유 대기(Hold and Wait) : 한 프로세스가 어떤 자원에 접근 중인 상태에서 다른 자원의 접근을 요구한다.
- 비선점(Non-Preemtion) : 한 프로세스가 어떤 자원의 사용이 끝나기 전까지는 그 자원을 반환할 수 없다.

- 순환 대기(Circular Wait) : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.

### DeadLock의 처리 방법

#### 1. 예방

DeadLock 발생 조건 중 하나를 제거함으로써 DeadLock의 발생 가능성을 원천 차단하는 방법

- 상호 배제 부정 : 여러 프로세스가 공유 자원에 접근할 수 있다.
- 점유 대기 부정 : 프로세스가 실행되기 전에 필요한 자원들을 모두 미리 할당한다.
- 비선점 부정 : 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구한 자원을 사용하기 위해 기다리게 한다.

- 순환 대기 부정 : 자원에 고유한 번호를 할당하고, 번호 순서대로 자원을 요구하도록 한다.

#### 2. 회피

DeadLock이 발생하지 않도록 적절히 피해나가는 방법

- 은행원 알고리즘
  - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사한다. 안정 상태가 된다고 판단되면 자원 할당, 아니면 다른 프로세스들이 자원을 해지할 때까지 대기한다.

#### 3. 탐지 및 회복

DeadLock이 발생하면 빠르게 발견하고 문제를 해결하는 방법. 시스템의 자원 할당 그래프를 이용하여 DeadLock을 검출한 뒤, DeadLock 상태의 프로세스를 모두 중지하거나, DeadLock이 제거될 때까지 하나씩 프로세스를 중지한다.

---

## 메모리 관리 기법

### 메모리 단편화 (Memory Fragmentation)

어떤 프로그램을 실행할 때, 메모리의 공간을 연속적인 형태로 할당해서 사용하게 된다. 이렇게 각 프로그램이 메모리에 할당되고 해제되고를 반복하다보면, 메모리 공간이 조각조각 나뉘게 되어 실제로는 사용 가능한 메모리가 충분히 존재하지만 할당이 불가능한 상태가 발생하게 된다.

#### 내부 단편화

프로세스가 필요한 양보다 더 큰 메모리가 할당되어서, 프로세스에서 사용되지 않는 메모리 공간이 생겨나는 상황

#### 외부 단편화

메모리의 할당 및 해제가 반복적으로 일어나서, 할당된 메모리와 메모리 사이에 중간중간 사용하지 않는 작은 메모리가 생겨나는 상황

#### MMU (Memory Management Unit)

논리 메모리와 물리 메모리 사이의 주소 변환 작업을 담당

즉, 프로세스에 메모리를 할당할 때 적절한 메모리 위치를 결정하는 작업을 담당

### 페이징 (Paging)

물리 메모리는 Frame이라는 고정 크기의 블록으로 분리되고, 논리 메모리(프로세스가 점유하는)는 Page라는 고정 크기의 블록으로 분리된다.

논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요 없이 물리 메모리의 남는 프레임에 적절하게 배치됨으로써 외부 단편화를 해결한다.

단, 내부 단편화를 해결해주지 못한다.

### 세그멘테이션 (Segmentation)

물리 메모리와 논리 메모리를 서로 다른 크기의 논리적 단위인 Segment로 분할한다.

논리 메모리를 해당 크기에 딱 맞는 세그먼트로 잘라 물리 메모리에 저장되기 때문에 내부 단편호를 해결한다.

단, 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 파편화되어 못쓰는 메모리가 많아질 수 있다. 즉, 외부 단편화를 해결해주지 못한다.

### Paging + Segmentation

두 기법의 단점을 모두 해결하기 위한 방법으로, 세그먼트를 다시 페이징하는 방식을 취한다.

---

## 가상 메모리

물리 메모리의 크기 한계를 극복하기 위한 것으로, 모든 프로세스가 메모리를 할당받지 않더라도 실행이 가능하도록 하는 기법

### Demand Paging

프로세스들을 같은 크기의 page로 쪼개서, 가장 우선적으로 필요한 page 몇 개만 메모리로 가져와서 실행시키는 방법

프로세스의 동작에 필요한 page를 요청하는 과정에서 page falut(페이지 부재)가 발생하게 되면, 원하는 페이지를 디스크로부터 가져와야 한다. 그러나 물리 메모리가 모두 사용 중이라면, 페이지 교체가 이루어져야 한다.

### 페이지 교체 알고리즘

- OPT(Optimal) : 앞으로 가장 오랫동안 사용되지 않을 페이지 교체
- FIFO(First In First Out) : 가장 먼저 들어온 페이지 교체
- LRU(Least Recently Used) : 가장 오랫동안 사용되지 않은 페이지 교체
- LFU(Least Frequently Used) : 참조 횟수가 가장 작은 페이지 교체
- MFU(Most Frequently used) : 참조 횟수가 가장 많은 페이지 교체
- NUR(Not Used Recently) : 최근에 사용하지 않은 페이지 교체

---

## 캐시 메모리

### 지역성

최근에 접근했던 영역과 같은 영역을 다시 접근하려는 경향

- 시간 지역성 : 한 번 참조된 메모리 위치는 다시 여러 번 참조될 가능성이 높다.
- 공간 지역성 : 어떤 프로그램이 어떤 메모리 위치를 참조하면, 이 프로그램은 나중에 근처의 메모리 위치를 참조할 가능성이 높다.

### 캐시 (Cache)

프로그램이 수행될 때 나타나는 지역성을 이용하여, 메모리나 디스크에서 사용되었던 내용을 다시 필요로 할 때 보다 빠르게 참조하도록 하기 위해, 특별히 빠르게 접근할 수 있는 곳에 보관하는 보관소

#### Cache hit

CPU가 참조하고자 하는 메모리가 캐시에 존재하고 있을 경우

#### Cache miss

CPU가 참조하고자 하는 메모리가 캐시에 존재하지 않을 경우
