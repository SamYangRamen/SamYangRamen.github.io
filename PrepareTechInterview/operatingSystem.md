# 운영체제

컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고, 효과적으로 사용할 수 있도록 환경을 제공하는 **여러 프로그램의 모임**.

운영체제는 소프트웨어로서 전원이 켜짐과 동시에 메모리에 올라가야 한다. 하지만, 운영체제처럼 규모가 큰 프로그램이 모두 메모리에 올라간다면 한정된 메모리 공간의 낭비가 심할것이다. 따라서 운영체제 중 **항상 필요한 부분**만을 전원이 켜짐과 동시에 메모리에 올려놓고 그렇지 않은 부분은 필요할 때 메모리에 올려서 사용하게 된다. 이 때 **메모리에 상주하는 운영체제의 부분을 커널**이라 한다.

## Process & Thread

### Process

- 메모리에 올라와 실행 중인 프로그램의 인스턴스

- 운영체제로부터 자신만의 독립된 메모리 영역을 할당받는다.

  - Code : 프로그램 소스코드 자체
  - Data : 전역변수, Static 변수, 배열, 구조체 등
  - Heap : 동적 할당
  - Stack : 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)

- 프로세스들은 독립적인 것이기 때문에, 한 프로세스가 다른 프로세스의 자원에 접근하려면 IPC(Inter Process Communication)를 사용해야 한다.

  - IPC : 파이프, 메시지 큐, 소켓 등을 이용한 통신

- 프로세스는 최소 1개의 쓰레드(메인 쓰레드)를 가지고 있다.

### Thread

- 프로세스 내의 실행 단위
- 프로세스의 자원을 쓰레드끼리 공유하기 때문에, 다른 쓰레드에 의한 결과를 즉시 확인할 수 있다.
- 단, 프로세스 내에서 Stack만 따로 할당받고, Code, Data, Heap 영역은 공유한다.
  - Stack을 독립적으로 할당하는 이유는, 쓰레드의 추가, 즉 독립적인 실행 흐름을 추가하기 위한 최소 조건이기 때문

### Multi-Processing

- 하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 1개의 작업을 처리하도록 하는 것

- 장점 : 안전성. 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다.
- 단점 : 비효율성. 프로세스들이 각각 독립된 메모리 영역을 갖기 때문에 Multi-Threading보다 많은 메모리 공간과 CPU 시간을 차지한다.

### Multi-Threading

- 하나의 프로그램을 여러 개의 쓰레드로 구성하여 각 쓰레드가 1개의 작업을 처리하도록 하는 것

- 장점 : 효율성. 쓰레드들이 같은 메모리 영역을 공유하기 때문에 Multi-Processing보다 적은 메모리 공간을 차지하고 Context Switching이 빠르다.
- 단점 : 위험성. 오류로 인해 하나의 쓰레드가 종료되면 전체 쓰레드가 종료될 위험이 있다.

### Context Switching

- 인터럽트를 발생시켜 CPU에서 현재 실행 중인 프로세스를 중단하고, 처리하고자 하는 다른 프로세스의 상태 정보를 CPU에 불러오는 과정
  - 인터럽트(Interrupt) : 예외 상황의 처리가 필요함을 CPU에게 알리는 것
- 현재 실행 중인 프로세스의 상태를 PCB에 저장하고, 다음 프로세스의 PCB 정보를 바탕으로 다음 프로세스를 동작시켜 작업을 처리한 후에, 이전에 저장되었던 프로세스의 상태를 해당 PCB로부터 다시 복구한다.
  - PCB(Process Control Block)
    - 각 프로세스에 대한 중요한 정보를 저장하는 자료구조
    - 프로세스가 생성/완료되면 해당 PCB가 생성/제거된다.

---

## 프로세스 동기화 (Process Synchronization)

### 경쟁 상태(Race Condition)

- 여러 프로세스가 공유 자원에 동시에 접근하여 결과값에 영향을 줄 수 있는 상태. 즉, 어떤 자원을 두고 여러 프로세스들이 경쟁하는 상태

- 예시 : 한 은행 계좌에 두 명이 동시에 입금/인출할 때

  ```java
  void deposit(int amount) {
    balance = balance + amount;
  }
  void withdraw(int amount) {
    balance = balance - amount;
  }
  ```

### 임계 구역(Critical Section)

- Multi-Process 환경에서 둘 이상의 프로세스가 동시에 접근할 수 있는 코드 영역
- 여러 프로세스가 동시에 Critical Section에 접근을 한다면 **Race Condition** 문제가 발생할 수 있다. 즉, 데이터의 일관성이 파괴된다.

### 프로세스 동기화

- 공유 데이터에 두 개 이상의 프로세스가 동시에 접근하는 것을 막는 것, 그럼으로써 데이터의 일관성을 유지하는 것

### 프로세스 동기화의 조건

※ 사람들은 'Critical Section 문제를 해결하기 위한 조건'이라고 더 많이 일컫는다.

- 상호 배제(**Mut**ual **Ex**clusion, Mutex) : 하나의 프로세스가 Critical Section에 들어가 있으면 다른 프로세스는 들어갈 수 없다.
- 진행(Progress) : Critical Section에 들어간 프로세스가 없다면, 어느 프로세스가 들어갈 것인지 적절히 선택해줘야 한다.
- 한정 대기(Bounded Waiting) : 어떤 프로세스가 영원히 공유 자원에 접근하지 못하는 상황이 발생하는 것을 막기 위해, 이미 Critical Section에 들어갔던 프로세스는 다음 번 접근에 제한을 두어야 한다.

### 프로세스 동기화의 방법 : Mutex vs Semaphore

| Mutex                                                                                                                   | Semaphore                                                                                |
| ----------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| 오직 하나의 쓰레드만이 Lock/Unlock을 수행한 뒤 Critical Section을 진입/탈출할 수 있다. 즉, 동기화 대상이 오직 하나이다. | 여러 쓰레드가 Critical Section에 동시에 진입할 수 있다. 즉, 동기화 대상이 하나 이상이다. |
| Lock/Unlock 동작을 통해 다른 스레드의 접근을 막는다.                                                                    | 접근 가능한 스레드의 수를 제한하는 변수이다.                                             |
| Mutex는 semaphore가 될 수 없다.                                                                                         | 이진 변수일 때, Mutex와 같다.                                                            |

---

## 교착 상태 (DeadLock)

둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 상황

### DeadLock의 4가지 조건

- 상호 배제(Mutual Exclusion) : 한번에 한 프로세스만 공유 자원에 접근할 수 있다.
- 점유 대기(Hold and Wait) : 한 프로세스가 어떤 자원에 접근 중인 상태에서 다른 자원의 접근을 요구한다.
- 비선점(Non-Preemtion) : 한 프로세스가 어떤 자원의 사용이 끝나기 전까지는 그 자원을 반환할 수 없다.

- 순환 대기(Circular Wait) : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.

### DeadLock의 처리 방법

#### 1. 예방

DeadLock 발생 조건 중 하나를 제거함으로써 DeadLock의 발생 가능성을 원천 차단하는 방법

- 상호 배제 부정 : 여러 프로세스가 공유 자원에 접근할 수 있다.
- 점유 대기 부정 : 프로세스가 실행되기 전에 필요한 자원들을 모두 미리 할당한다.
- 비선점 부정 : 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구한 자원을 사용하기 위해 기다리게 한다.

- 순환 대기 부정 : 자원에 고유한 번호를 할당하고, 번호 순서대로 자원을 요구하도록 한다.

#### 2. 회피

DeadLock이 발생하지 않도록 적절히 피해나가는 방법

- 은행원 알고리즘
  - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사한다. 안정 상태가 된다고 판단되면 자원 할당, 아니면 다른 프로세스들이 자원을 해지할 때까지 대기한다.

#### 3. 탐지 및 회복

DeadLock이 발생하면 빠르게 발견하고 문제를 해결하는 방법. 시스템의 자원 할당 그래프를 이용하여 DeadLock을 검출한 뒤, DeadLock 상태의 프로세스를 모두 중지하거나, DeadLock이 제거될 때까지 하나씩 프로세스를 중지한다.

---

## 메모리 관리 기법

### 메모리 단편화 (Memory Fragmentation)

어떤 프로그램을 실행할 때, 메모리의 공간을 연속적인 형태로 할당해서 사용하게 된다. 이렇게 각 프로그램이 메모리에 할당되고 해제되고를 반복하다보면, 메모리 공간이 조각조각 나뉘게 되어 실제로는 사용 가능한 메모리가 충분히 존재하지만 할당이 불가능한 상태가 발생하게 된다.

#### 내부 단편화

프로세스가 필요한 양보다 더 큰 메모리가 할당되어서, 프로세스에서 사용되지 않는 메모리 공간이 생겨나는 상황

#### 외부 단편화

메모리의 할당 및 해제가 반복적으로 일어나서, 할당된 메모리와 메모리 사이에 중간중간 사용하지 않는 작은 메모리가 생겨나는 상황

### 페이징 (Paging)

물리 메모리는 Frame이라는 고정 크기의 블록으로 분리되고, 논리 메모리(프로세스가 점유하는)는 Page라는 고정 크기의 블록으로 분리된다.

논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요 없이 물리 메모리의 남는 프레임에 적절하게 배치됨으로써 외부 단편화를 해결한다.

단, 내부 단편화를 해결해주지 못한다.

### 세그멘테이션 (Segmentation)

물리 메모리와 논리 메모리를 서로 다른 크기의 논리적 단위인 Segment로 분할한다.

---

## 페이지 교체 알고리즘

### LRU

### RR
