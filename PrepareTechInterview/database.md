# 데이터베이스

- 데이터베이스 : 데이터 저장소
- DBMS : 데이터베이스를 운영 및 관리하는 소프트웨어. 다수의 사용자들이 데이터베이스 내의 데이터에 접근할 수 있도록 해주는 소프트웨어
- SQL : 관계형 데이터베이스에서 사용되는 질의 언어

---

## 데이터베이스 개념

### 데이터베이스의 정의

- 통합된 데이터(Integrated Data)

  - 검색의 효율성을 위해 자료의 **중복을 최소화**한 데이터의 모임

- 저장된 데이터(Stored Data)

  - 컴퓨터가 접근할 수 있는 **저장 매체에 저장**된 데이터

- 운영 데이터(Operational Data)

  - 조직의 고유한 업무를 수행하는 데 존재 가치가 확실하고 없어서는 안 될 **반드시 필요한 데이터**

- 공용 데이터(Shared Data)
  - 여러 응용 시스템들이 **공동으로 사용**하는 데이터

### 데이터베이스의 특징

- 실시간 접근성(Real-Time Accessibility)

  - 사용자의 질의에 대하여 **즉시 처리하여 응답**

- 계속적인 변화(Continuous Evolution)

  - 삽입, 삭제, 갱신을 통하여 항상 **최신의 데이터를 유지**해야 함

- 동시 공용(Concurrent Sharing)

  - 데이터베이스는 서로 다른 목적을 가진 여러 응용자들을 위한 것이므로 다수의 사용자가 **동시에 같은 내용의 데이터를 이용**할 수 있어야 함

- 내용에 의한 참조(Content Reference)
  - 데이터베이스에 있는 데이터를 참조할 때, 데이터 레코드의 주소나 위치에 의해서가 아니라, 사용자가 요구하는 데이터 **내용으로 데이터를 찾음**

### DBMS의 특징

DBMS는 파일 시스템의 문제점을 해결하기 위해 만들어졌기 때문에, DBMS의 특징은 곧 파일 시스템의 단점을 의미한다.

- 데이터의 독립성

  - 물리적 독립성 : 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다.
  - 논리적 독립성 : 데이터의 논리적 구조를 변경시키더라도 응용프로그램의 구조는 변경되지 않는다.

- 데이터의 무결성

  - 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.

- 데이터의 보안성

  - 인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다.

- 데이터의 일관성
  - 연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다.
- 데이터 중복 최소화
  - 데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.

---

## 데이터베이스 구조

![image](https://user-images.githubusercontent.com/53200166/158192310-e1c7d013-5868-41be-a8ca-8effbbc37a10.png)

![image](https://user-images.githubusercontent.com/53200166/158192110-e4c8c836-8aaa-40ee-9015-91914e62e6af.png)

![image](https://user-images.githubusercontent.com/53200166/158192592-6e41a8dd-aac9-4bab-ae3f-367260db6f7a.png)

### 외부 스키마

사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것으로, 엔티티, 속성 및 관계가 매핑되는 방식을 정의한다. 쉽게 말하면 테이블 또는 (JOIN 등을 통한) 테이블의 결합을 SELECT한 것을 나타낸다. 한 데이터베이스에서 외부 스키마는 수없이 많이 존재할 수 있다.

### 개념 스키마

조직 전체의 관점에서 생각하는 데이터베이스의 모습. 전체 데이터베이스에 어떤 데이터가 저장되는지, 그 데이터들은 어떤 테이블에 있고, 각 테이블 간에는 어떤 관계가 존재하고 어떤 제약조건이 존재하는지에 대한 정의뿐만 아니라, 데이터에 대한 보안 정책이나 접근 권한에 대한 정의도 포함한다. 한 데이터베이스에서 개념 스키마는 오직 하나 뿐이다.

### 내부 스키마

어떤 데이터가 어떤 테이블의 어떤 row의 어떤 애트리뷰트에 있다는 개념이 아니라, B-트리 자료구조의 어디에 저장되어 있고, 디스크의 어느 위치에, 메모리의 어느 페이지에 저장돼 있는지의 관점으로 바라보는 개념이다. 우리는 단순히 INSERT로 데이터를 삽입하지만 이 INSERT문에 의해 저장되는 그 VALUES는 어떠한 알고리즘으로 하드디스크의 어떠한 부분에 저장이 될 것이다. 이런 시스템적인, 물리적인 시각의 스키마가 내부 스키마이다. 한 데이터베이스에서 내부 스키마는 오직 하나 뿐이다.

---

## 데이터베이스 설계

![image](https://user-images.githubusercontent.com/53200166/158201401-95636030-e669-4148-9220-9e19905ff5ee.png)

### 용어 정리

![image](https://user-images.githubusercontent.com/53200166/158223173-0494573f-3b31-4d3f-930a-82f6c1e65752.png)

### 개념적 설계

사용자 요구사항을 분석한 내용을 기반으로 중요한 개체를 추출하고, 각 개체간의 관계를 설정하여 E-R 다이어그램을 만드는 과정

![image](https://user-images.githubusercontent.com/53200166/158204766-2d5f5bab-01cb-4632-94ef-ddc5b5a98d99.png)

- E-R 다이어그램 표기법

  ![image](https://user-images.githubusercontent.com/53200166/158212220-50178347-4709-462d-8f8d-54316fca253c.png)

### 논리적 설계

E-R 다이어그램을 사용하여 릴레이션 스키마(즉, 테이블)를 만드는 과정

- 릴레이션 스키마 생성

  ![image](https://user-images.githubusercontent.com/53200166/158210021-762adf17-dbb7-41a3-be36-5719ed0d63ed.png)

- 테이블 명세

  ![image](https://user-images.githubusercontent.com/53200166/158210832-4da4ea32-5507-4b37-962d-974fa016753a.png)

#### 논리적 설계 규칙

- **모든 개체(엔티티)는 릴레이션으로 변환한다.**

  - 개체를 릴레이션으로 변환할 때

    ![image](https://user-images.githubusercontent.com/53200166/158204563-fbb9de6e-7a3f-47fa-b296-fb8b9e51edff.png)

  - 복합 속성을 가지는 개체를 릴레이션으로 변환할 때

    ![image](https://user-images.githubusercontent.com/53200166/158205042-134c2087-ae12-469d-9cf9-a984d102e7e8.png)

- **다대다 관계는 릴레이션으로 변환한다.**

  ![image](https://user-images.githubusercontent.com/53200166/158205559-6cf8747e-d941-4047-a57c-8092db48d00a.png)

- **일대다 관계는 외래키로 표현한다.**

  - 일반적인 일대다 관계를 외래키로 표현할 때

    ![image](https://user-images.githubusercontent.com/53200166/158206087-31b90dcd-520f-488c-a053-8d9284fc1a85.png)

  - 약한 개체가 참여하는 일대다 관계를 외래키로 표현할 때 : 외래키를 포함해서 기본키로 지정한다.

    ![image](https://user-images.githubusercontent.com/53200166/158206589-e99c2f8e-efd5-48d0-a18a-4d51bfab5c04.png)

- **일대일 관계는 외래키로 표현한다.**

  - 일반적인 일대일 관계를 외래키로 표현할 때 : 외래키를 서로 주고받는다.

    ![image](https://user-images.githubusercontent.com/53200166/158207446-bef72d3d-ecda-47e8-b6f9-28b1a60f8405.png)

  - 일대일 관계에 필수적으로 참여하는 개체의 릴레이션만 외래키를 받는다.

    ![image](https://user-images.githubusercontent.com/53200166/158208662-22276f67-79d5-41cb-ad86-d3f360f418f3.png)

  - 모든 개체가 필수적으로 참여하면 하나의 릴레이션으로 합친다.

    ![image](https://user-images.githubusercontent.com/53200166/158208474-62838af7-13e1-4a3d-bbd4-4c5708d54122.png)

- **다중값 속성은 릴레이션으로 변환한다.**

  ![image](https://user-images.githubusercontent.com/53200166/158209005-9497f02e-c645-4bf5-8f98-501b38beea4b.png)

- 기타 고려사항

  - 속성이 많은 관계는 유형에 상관없이 릴레이션으로의 변환을 고려할 수 있다.

    ![image](https://user-images.githubusercontent.com/53200166/158209336-b1e37dcd-7bef-4b73-ab50-3232be858439.png)

  - 개체가 자기 자신과 관계를 맺는 순환 관계도 기본 규칙을 그대로 적용한다.

    ![image](https://user-images.githubusercontent.com/53200166/158209572-f9bff1d6-f3e0-4a51-bc6e-761da6de931a.png)

### 물리적 설계

릴레이션 스키마 모델의 물리적 구조를 정의하고 구현하는 과정

![image](https://user-images.githubusercontent.com/53200166/158211148-d303605f-8330-46ad-87a9-b49ef790fcb1.png)

---

## 데이터베이스 제약조건

### Key

![image](https://user-images.githubusercontent.com/53200166/158224042-3df04730-2045-4812-b82f-c93f7524a7ea.png)

- 슈퍼키 : 각 튜플을 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합
- 후보키 : 튜플을 유일하게 식별할 수 있는 속성의 최소 집합
- 기본키 : 후보키 중 대표로 삼는 키
- 대체키 : 기본키를 제외한 후보키
- 외래키 : 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합

### 무결성 제약조건

- 개체 무결성 : 기본키는 NULL값과 중복값을 가질 수 없다.
  - PRIMARY KEY
- 참조 무결성 : 외래키는 NULL이거나 참조하는 릴레이션의 기본키의 값과 동일해야 한다.
  - FOREIGN KEY
- 도메인 무결성 : 특정 속성에 대해 도메인을 설정한 경우, 속성의 값은 정해진 도메인 영역을 벗어나지 않아야 한다.
  - 자료형, CHECK, DEFAULT
- 고유 무결성 : 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 그 속성값은 모두 달라야 한다.
  - UNIQUE
- NULL 무결성 : 특정 속성에 대해 NULL이 올 수 없다는 조건이 주어진 경우, 그 속성값은 NULL이 될 수 없다.
  - NOT NULL
- 키 무결성 : 한 릴레이션에는 최소한 하나의 키가 존재해야 한다.
  - PRIMARY KEY + UNIQUE INDEX

---

## 데이터베이스 정규화

정규화를 해야 하는 이유는 잘못된 테이블 설계로 인해 Anomaly(이상 현상)가 발생하기 때문이다.

- 삽입 이상 : 원하지 않는 자료가 삽입되거나 원하는 자료가 삽입되지 않는 것
- 삭제 이상 : 원하지 않는 자료까지 함께 삭제되는 것
- 갱신 이상 : 정보를 갱신할 때 일부만 갱신되어 모순(데이터 불일치)이 발생하는 것

![image](https://user-images.githubusercontent.com/53200166/158236453-60537774-ba2c-40f4-a256-8672d2842bf7.png)

### 함수 종속성

- 완전 함수 종속
  - 종속자가 기본키 자체에 종속되며 기본키의 어떤 진부분집합에도 종속되지 않을 때. 즉, 기본키의 모든 속성을 알아야지만 종속자를 식별할 수 있을 때
- 부분 함수 종속
  - 종속자가 기본키가 아닌 다른 속성에 종속되거나, 기본키가 여러 속성으로 구성되어 있을 경우 기본키를 구성하는 속성 중 일부에만 종속될 때
- 이행 함수 종속
  - A -> B이고 B -> C이면 A -> C일 때

### 1NF

모든 도메인이 원자값으로 이루어지도록 한다.

- 1NF를 만족하지 않을 경우
  - 갱신 이상 : `홍길동`이 `사회` 과목을 `역사`로 바꾸면, `임꺽정`이 듣고 있던 `사회` 과목도 `역사`로 바뀌어버린다.
  - 삭제 이상 : `임꺽정`이 `과학` 과목을 수강 취소하면, `신사임당`의 수강 정보도 삭제된다.

![image](https://user-images.githubusercontent.com/53200166/158233382-54587dbe-cb35-4daf-8de2-953f2df8deee.png)

### 2NF

1NF를 만족하면서, 키가 아닌 모든 attribute가 기본키에 완전 함수 종속이어야 한다. 그러기 위해서는 부분 함수 종속을 제거한다.

- 예시에서는 `{학번} -> {이름, 소속학과, 학과장}` 이고 `{소속학과} -> {학과장}` 이다. 즉, `학과장`이 기본 키가 아닌 다른 속성인 `{소속학과}`에 종속되므로 부분 함수 종속적이다.
  - 삽입이상 : `컴퓨터과`, `전자과`, `기계과` 학생을 추가하고자 할 경우 더이상 불필요한 중복정보인 `학과장` 정보가 삽입되야 한다.
  - 갱신이상 : `컴퓨터과`의 `학과장`이 변경될 때, 하나만 변경하면 모순이 발생하므로 다 찾아서 변경해야 한다.
  - 삭제이상 : `신사임당`이 자퇴해서 삭제하고자 한다. 이 삭제로 인해 `기계과`의 `학과장` 정보가 사라져버린다.

![image](https://user-images.githubusercontent.com/53200166/158233635-da92e553-5bd4-4301-b17c-255e9c61c1e7.png)

### 3NF

2NF를 만족하면서, 키가 아닌 모든 attribute가 기본키에 직접 종속이어야 한다. 그러기 위해서는 이행 함수 종속을 제거한다.

- 예시에서는 `{학번}` -> `{소속학과}` 이고 `{소속학과}` -> `{대학}` 이므로 이행 함수 종속적이다.
  - 삽입이상 : `컴퓨터과`, `전자과` 학생을 추가하고자 할 경우 더이상 불필요한 중복정보인 `대학` 정보가 삽입되어야 한다.
  - 갱신이상 : `컴퓨터과`의 소속 대학이 `정보통신`으로 변경될 때, 하나만 변경하면 모순이 발생하므로 다 찾아서 변경해야 한다.
  - 삭제이상 : `홍길동`이 자퇴해서 삭제하고자 한다. 이 삭제로 인해 `컴퓨터`과의 `대학` 정보가 사라져 버린다.

![image](https://user-images.githubusercontent.com/53200166/158233856-849f11f0-c034-4c81-a728-beaa237eb729.png)

### BCNF

3NF를 만족하면서, 릴레이션의 모든 결정자가 후보키여야 한다.

- 예시에서는 `{학번, 과목}`이 `교수`를 결정짓고, `교수`가 `과목`을 결정짓는다. 즉, `교수` 또한 결정자인데 `교수`는 `학번`을 결정지을 수 없으므로 후보키는 아니다.
  - 삽입이상 : `200` 학생이 `데이터베이스`를 수강하고자 할 경우, 현재 불필요한 `홍길동` 교수 정보가 한번 더 삽입된다.
  - 갱신이상 : `홍길동`의 담당 과목이 `알고리즘`으로 바뀔 때, `100` 학생의 수강 과목이 변경되어 버린다.
  - 삭제이상 : `300` 학생이 자퇴해서 삭제하고자 한다. 이 삭제로 인해 `인공지능` 과목을 `유관순` 교수가 담당하고 있다는 정보가 사라진다.

![image](https://user-images.githubusercontent.com/53200166/158234045-596fc092-a55b-49eb-aa2a-6089801a5314.png)

---

## INDEX

---

## 트랜잭션
